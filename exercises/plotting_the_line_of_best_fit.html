<!DOCTYPE html>
<html data-require="math math-format graphie interactive">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Plotting the line of best fit</title>
    <script src="../khan-exercise.js"></script>
    <style type="text/css">
        .graphie.float {
            float: left;
            margin-right: 10px;
        }
    </style>
</head>
<body>
<div class="exercise">
    <div class="problems">
        <div>
            <div class="vars">
                <var id="SLOPE">randRange(-100, 100) / 20</var>
                <var id="INTERCEPT">randRange(-5, 5)</var>
                <var id="FUNC">function(x) { return SLOPE * x + INTERCEPT }</var>
                <var id="TOP">((SLOPE < 0 ? -1 : 1) * 10 - INTERCEPT) / SLOPE</var>
                <var id="BOTTOM">((SLOPE < 0 ? 1 : -1) * 10 - INTERCEPT) / SLOPE</var>
                <var id="BOUND">function(x, low, high) {
                    return (x < low) ? low : (x > high) ? high : x;
                }</var>
                <var id="OFFSET">random() + 0.5</var>
                <var id="LEFT">(BOTTOM < -10) ? -10 : BOTTOM</var>
                <var id="RIGHT">(TOP > 10) ? 10 : TOP</var>
                <var id="XS">(function() {
                    var range = (RIGHT - LEFT) / 20;

                    return _.map(shuffle(_.range(-8, 9), 7), function(x) {
                        return x * range;
                    });
                })()</var>
                <var id="UNIQARRAYS">function(a) {
                    for (var i = 0; i < a.length; ++i) {
                        for (var j = i + 1; j < a.length; ++j) {
                            if (_.isEqual(a[i], a[j])) {
                                a.splice(j, 1);
                                --j;
                            }
                        }
                    }
                    return a;
                }</var>
                <var id="RR">function(low, high) {
                    return random() * (high - low) + low;
                }</var>
                <var id="ANG">atan2(SLOPE, 1) + PI / 2</var>
                <var id="PERP">[cos(ANG), sin(ANG)]</var>
                <var id="TOTALOFFSET">[]</var>
                <var id="POINTS">_.sortBy(UNIQARRAYS(_.map(XS, function(x) {
                    var total = _.reduce(TOTALOFFSET, function(sum, num) {
                        return sum + num;
                    }, 0);

                    var scale = 2 * OFFSET - abs(total);

                    var offset;
                    if (total < 0) {
                        offset = RR(-OFFSET - total, OFFSET);
                    } else {
                        offset = RR(-OFFSET, OFFSET - total);
                    }

                    TOTALOFFSET.push(offset);

                    return [BOUND(round(x + PERP[0] * offset), -9, 9),
                            BOUND(round(FUNC(x) + PERP[1] * offset), -9, 9)];
                    })), function(pt) { return pt[0]; })</var>
                <var id="REALSLOPE,REALINTERCEPT">(function() {
                    var xAve = _.reduce(POINTS, function(sum, pt) {
                        return sum + pt[0];
                    }, 0) / POINTS.length;

                    var yAve = _.reduce(POINTS, function(sum, pt) {
                        return sum + pt[1];
                    }, 0) / POINTS.length;

                    var xi2 = _.reduce(POINTS, function(sum, pt) {
                        return sum + pow(pt[0], 2);
                    }, 0);

                    var xiyi = _.reduce(POINTS, function(sum, pt) {
                        return sum + pt[0] * pt[1];
                    }, 0);

                    var realIntercept = (yAve * xi2 - xAve * xiyi) /
                        (xi2 - POINTS.length * pow(xAve, 2));
                    var realSlope = (xiyi - POINTS.length * xAve * yAve) /
                        (xi2 - POINTS.length * pow(xAve, 2));

                    return [realSlope, realIntercept];
                })()</var>
                <var id="GRAPH">{}</var>
            </div>

            <p class="question">Find the line of best fit</p>
            <div class="problem">
                <div class="graphie">
                    graphInit({
                        range: 11,
                        scale: 20,
                        axisArrows: "&lt;-&gt;",
                        tickStep: 1,
                        labelStep: 1,
                        gridOpacity: 0.05,
                        axisOpacity: 0.2,
                        tickOpacity: 0.4,
                        labelOpacity: 0.5
                    });

                    _.each(POINTS, function(pt) {
                        circle(pt, 0.2, { fill: "black" });
                    });

                    addMouseLayer();
                    graph.pointA = addMovablePoint({
                        coord: [-5, 5],
                        snapX: 0.5,
                        snapY: 0.5,
                        normalStyle: {
                            stroke: KhanUtil.BLUE,
                            fill: KhanUtil.BLUE
                        }
                    });
                    graph.pointB = addMovablePoint({
                        coord: [5, 5],
                        snapX: 0.5,
                        snapY: 0.5,
                        normalStyle: {
                            stroke: KhanUtil.BLUE,
                            fill: KhanUtil.BLUE
                        }
                    });
                    graph.line1 = addMovableLineSegment({
                        pointA: graph.pointA,
                        pointZ: graph.pointB,
                        fixed: true,
                        extendLine: true
                    });

                    // A and B can't be in the same place
                    graph.pointA.onMove = function(x, y) {
                        return (x != graph.pointB.coord[0] ||
                            y != graph.pointB.coord[1]);
                    }
                    graph.pointB.onMove = function(x, y) {
                        return (x != graph.pointA.coord[0] ||
                            y != graph.pointA.coord[1]);
                    }

                    graph.pointA.toFront();
                    graph.pointB.toFront();

                    graph.showSolution = function() {
                        var roundToHalf = function(x) {
                            return round(x * 2) / 2;
                        };

                        var realFunc = function(x) {
                            return REALSLOPE * x + REALINTERCEPT;
                        };

                        $("html, body").animate({
                            scrollTop: $(".question").offset().top
                        }, {
                            duration: 500,
                            easing: "swing",
                            complete: function() {
                                var coords = {
                                    x1: graph.pointA.coord[0],
                                    y1: graph.pointA.coord[1],
                                    x2: graph.pointB.coord[0],
                                    y2: graph.pointB.coord[1]
                                };
                                var left = LEFT + (RIGHT - LEFT) * 0.1;
                                var right = RIGHT - (RIGHT - LEFT) * 0.1;
                                $(coords).delay(100).animate({
                                    x1: roundToHalf(left),
                                    y1: roundToHalf(realFunc(left)),
                                    x2: roundToHalf(right),
                                    y2: roundToHalf(realFunc(right))
                                }, {
                                    duration: 500,
                                    easing: "linear",
                                    step: function( now, fx ) {
                                        coords[ fx.prop ] = now;
                                        graph.pointA.setCoord([ coords.x1, coords.y1 ]);
                                        graph.pointB.setCoord([ coords.x2, coords.y2 ]);

                                        graph.line1.transform(true);
                                    }
                                });
                            }
                        });
                    };

                    GRAPH = graph;
                </div>
            </div>

            <div class="solution" data-type="custom">
                <div class="instruction">
                    Move the line to be a line of best fit for the data points.
                </div>
                <div class="guess">
                    [GRAPH.pointA.coord, GRAPH.pointB.coord]
                </div>
                <div class="validator-function">
                    if (_.isEqual([-5, 5], guess[0]) &amp;&amp;
                        _.isEqual([5, 5], guess[1])) {
                        return "";
                    }

                    // the slope and intercept of the given line
                    var slope = (guess[0][1] - guess[1][1]) /
                        (guess[0][0] - guess[1][0]);
                    var intercept = slope * -guess[0][0] + guess[0][1];

                    // whether or not each of the points are above or below
                    // the given line
                    var updown = _.map(POINTS, function(pt) {
                        var x = pt[0], y = pt[1],
                            est = slope * x + intercept;
                        return y &gt;= est ? 1 : -1;
                    });

                    // sort and reverse-sort updown
                    var updownSorted = sortNumbers(updown);
                    var updownReversed = updownSorted.slice(0).reverse();

                    var normLength = pow((guess[1][0] - guess[0][0]), 2) + pow((guess[1][1] - guess[0][1]), 2);
                    // calculate the distance from a point to the line
                    var distTo = function(pt) {
                        return abs((pt[0] - guess[0][0]) * (guess[1][1] - guess[0][1]) -
                                   (pt[1] - guess[0][1]) * (guess[1][0] - guess[0][0])) / normLength;
                    };

                    // the average distance the points are from the line
                    var aveDist = _.reduce(POINTS, function(sum, pt) {
                        return sum + pow(distTo(pt), 2);
                    }, 0) / sqrt(POINTS.length);

                    // ensure:
                    // all the points are not up, ..., up, down, ..., down
                    return !_.isEqual(updown, updownSorted) &amp;&amp;
                        // all the points are not down, ..., down, up, ..., up
                        !_.isEqual(updown, updownReversed) &amp;&amp;
                        // one point is above
                        _.include(updown, 1) &amp;&amp;
                        // one point is below
                        _.include(updown, -1) &amp;&amp;
                        // the average distance is within some distance,
                        // proportional to the offest
                        aveDist &lt; 0.6 * OFFSET;
                </div>
                <div class="show-guess">
                    GRAPH.pointA.coord = guess[0];
                    GRAPH.pointB.coord = guess[1];

                    GRAPH.line1.transform(true);
                </div>
            </div>

            <div class="hints">
                <p>The line of best fit is the line that best approximates
                    the data points.</p>
                <div>
                    <p>First, make sure that your line passes through the points,
                        and does not lie completely above or below the points.</p>
                    <div class="clearfix">
                        <div class="graphie float">
                            init({ range: [[-5, 5], [-5, 5]], scale: [20, 20] });

                            circle([-2, -3], 0.2, { fill: "black" });
                            circle([ 0, -1], 0.2, { fill: "black" });
                            circle([-1,  1], 0.2, { fill: "black" });
                            circle([ 1,  1], 0.2, { fill: "black" });
                            circle([ 0,  2], 0.2, { fill: "black" });

                            line([-5, -4], [5, -3], { stroke: BLUE });

                            label([0, 4], "Bad", "center", false)
                                .css("color", "red")
                                .css("font-size", "20px");
                        </div>
                        <div class="graphie float">
                            init({ range: [[-5, 5], [-5, 5]], scale: [20, 20] });

                            circle([-2, -3], 0.2, { fill: "black" });
                            circle([ 0, -1], 0.2, { fill: "black" });
                            circle([-1,  1], 0.2, { fill: "black" });
                            circle([ 1,  1], 0.2, { fill: "black" });
                            circle([ 0,  2], 0.2, { fill: "black" });

                            line([-5, -4], [5, 3], { stroke: BLUE });

                            label([0, 4], "Good", "center", false)
                                .css("color", "green")
                                .css("font-size", "20px");
                        </div>
                    </div>
                </div>
                <div>
                    <p>Next, make sure that your line alternates between
                        passing above and then below points, and doesn't simply
                        go above some points and then below the rest.</p>
                    <div class="clearfix">
                        <div class="graphie float">
                            init({ range: [[-5, 5], [-5, 5]], scale: [20, 20] });

                            circle([-2, -3], 0.2, { fill: "black" });
                            circle([ 0, -1], 0.2, { fill: "black" });
                            circle([-1,  1], 0.2, { fill: "black" });
                            circle([ 1,  1], 0.2, { fill: "black" });
                            circle([ 0,  2], 0.2, { fill: "black" });

                            line([-5, -2.5], [5, -1.5], { stroke: BLUE });

                            label([0, 4], "Bad", "center", false)
                                .css("color", "red")
                                .css("font-size", "20px");
                        </div>
                        <div class="graphie float">
                            init({ range: [[-5, 5], [-5, 5]], scale: [20, 20] });

                            circle([-2, -3], 0.2, { fill: "black" });
                            circle([ 0, -1], 0.2, { fill: "black" });
                            circle([-1,  1], 0.2, { fill: "black" });
                            circle([ 1,  1], 0.2, { fill: "black" });
                            circle([ 0,  2], 0.2, { fill: "black" });

                            line([-4, -5], [4, 5], { stroke: BLUE });

                            label([0, 4], "Good", "center", false)
                                .css("color", "green")
                                .css("font-size", "20px");
                        </div>
                    </div>
                </div>
                <div>
                    <p>Last, make sure that the line goes through the middle
                        of all the points, so that it is close to all of
                        the points.</p>
                    <div class="clearfix">
                        <div class="graphie float">
                            init({ range: [[-5, 5], [-5, 5]], scale: [20, 20] });

                            circle([-2, -3], 0.2, { fill: "black" });
                            circle([ 0, -1], 0.2, { fill: "black" });
                            circle([-1,  1], 0.2, { fill: "black" });
                            circle([ 1,  1], 0.2, { fill: "black" });
                            circle([ 0,  2], 0.2, { fill: "black" });

                            line([-5, -3.5], [3, 5], { stroke: BLUE });

                            label([0, 4], "Bad", "center", false)
                                .css("color", "red")
                                .css("font-size", "20px");
                        </div>
                        <div class="graphie float">
                            init({ range: [[-5, 5], [-5, 5]], scale: [20, 20] });

                            circle([-2, -3], 0.2, { fill: "black" });
                            circle([ 0, -1], 0.2, { fill: "black" });
                            circle([-1,  1], 0.2, { fill: "black" });
                            circle([ 1,  1], 0.2, { fill: "black" });
                            circle([ 0,  2], 0.2, { fill: "black" });

                            line([-4, -5], [3, 5], { stroke: BLUE });

                            label([0, 4], "Good", "center", false)
                                .css("color", "green")
                                .css("font-size", "20px");
                        </div>
                    </div>
                </div>
                <p>
                    There are several lines that satisfy this.
                    <input type="submit" value="Click here" onclick="javascript:KhanUtil.tmpl.getVAR('GRAPH').showSolution()"/>
                    to show one of them.
                </p>
            </div>
        </div>
    </div>
</div>
</body>
</html>
